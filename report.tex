\documentclass[12pt]{article}

\usepackage[letterpaper, hmargin=0.75in, vmargin=0.75in]{geometry}
\usepackage{float}
\usepackage{url}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{courier}
\usepackage{tikz}

\lstset{basicstyle=\footnotesize\ttfamily}

\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]

\title{SE465-001 Project}
\author{Sameer Ahmad (20458331) \and Patrick White (11111111) \and Andrew Yiu (11111111)}
\date{April 6, 2015}

\begin{document}

\maketitle

\section*{Question 1 b}
Bug 1 (6 line locations):
\begin{lstlisting}
bug: apr_array_make in ap_init_virtual_host, pair: (apr_array_make, apr_array_push), support: 40, confidence: 86.96%
\end{lstlisting}
Code for ap\_init\_virtual\_host:
\begin{lstlisting}
AP_CORE_DECLARE(const char *) ap_init_virtual_host(apr_pool_t *p,
						const char *hostname,
						server_rec *main_server,
						server_rec **ps)
{
	server_rec *s = (server_rec *) apr_pcalloc(p, sizeof(server_rec));
	
	/* TODO: this crap belongs in http_core */
	s->process = main_server->process;
	s->server_admin = NULL;
	s->server_hostname = NULL;
	s->server_scheme = NULL;
	s->error_fname = NULL;
	s->timeout = 0;
	s->keep_alive_timeout = 0;
	s->keep_alive = -1;
	s->keep_alive_max = -1;
	s->error_log = main_server->error_log;
	s->loglevel = main_server->loglevel;
	/* useful default, otherwise we get a port of 0 on redirects */
	s->port = main_server->port;
	s->next = NULL;
	
	s->is_virtual = 1;
	s->names = apr_array_make(p, 4, sizeof(char **));
	s->wild_names = apr_array_make(p, 4, sizeof(char **));
	
	s->module_config = create_empty_config(p);
	s->lookup_defaults = ap_create_per_dir_config(p);
	
	s->limit_req_line = main_server->limit_req_line;
	s->limit_req_fieldsize = main_server->limit_req_fieldsize;
	s->limit_req_fields = main_server->limit_req_fields;
	
	*ps = s;
	
	return ap_parse_vhost_addrs(p, hostname, s);
}
\end{lstlisting}

This bug indicates a false positive. The bug reported by the static analysis tool states that calling apr\_array\_make without apr\_array\_push is considered a bug, given that in 86.96\% of uses of apr\_array\_make, the function will use apr\_array\_push as well. The reason that in this case the function does not call apr\_array\_push is because the array that is made is constructed with arguments that do not need pushed values. It is constructed on some values passed in and therefore needs no pushing to.\\\\
Bug 2 (4 line locations):
\begin{lstlisting}
bug: qsort in ap_core_reorder_directories, pair: (qsort, strcmp), support: 4, confidence: 66.67%
\end{lstlisting}
Code for ap\_core\_reorder\_directories
\begin{lstlisting}
void ap_core_reorder_directories(apr_pool_t *p, server_rec *s)
	{
	core_server_config *sconf;
	apr_array_header_t *sec_dir;
	struct reorder_sort_rec *sortbin;
	int nelts;
	ap_conf_vector_t **elts;
	int i;
	apr_pool_t *tmp;
	
	sconf = ap_get_module_config(s->module_config, &core_module);
	sec_dir = sconf->sec_dir;
	nelts = sec_dir->nelts;
	elts = (ap_conf_vector_t **)sec_dir->elts;
	
	if (!nelts) {
	/* simple case of already being sorted... */
	/* We're not checking this condition to be fast... we're checking
	* it to avoid trying to palloc zero bytes, which can trigger some
	* memory debuggers to barf
	*/
	return;
	}
	
	/* we have to allocate tmp space to do a stable sort */
	apr_pool_create(&tmp, p);
	sortbin = apr_palloc(tmp, sec_dir->nelts * sizeof(*sortbin));
	for (i = 0; i < nelts; ++i) {
	sortbin[i].orig_index = i;
	sortbin[i].elt = elts[i];
	}
	
	qsort(sortbin, nelts, sizeof(*sortbin), reorder_sorter);
	
	/* and now copy back to the original array */
	for (i = 0; i < nelts; ++i) {
	elts[i] = sortbin[i].elt;
	}
	
	apr_pool_destroy(tmp);
	}
\end{lstlisting}

This bug line does represents a false positive. The function qsort is used to sort a set of object, while strcmp is used to compare strings - this means that if the objects that are to be sorted do not rely on strings for ordering, then there would be no reason to use the strcmp function, which is the case here - this function is sorting elts which are not or do not rely on string comparrisons.

\end{document}